# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from funcs.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from dataclasses import dataclass
from datetime import date, datetime
from enum import Enum
from psycopg import AsyncConnection
from typing import List, Optional, Tuple, Dict, Any
from typing import TypeVar, Sequence
from uuid import UUID

class CompanyRole(Enum):
    OWNER = 'owner'
    ADMIN = 'admin'
    MEMBER = 'member'


@dataclass
class UserIdentity:
    id: Optional[UUID]
    clerk_id: Optional[str]


@dataclass
class User:
    id: UUID
    clerk_id: str
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    is_deleted: Optional[bool]


@dataclass
class Company:
    id: UUID
    name: str
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: datetime
    updated_at: datetime
    created_by_user_id: UUID


@dataclass
class Location:
    id: UUID
    company_id: UUID
    name: str
    address: Optional[str]
    city: Optional[str]
    state: Optional[str]
    country: Optional[str]
    zip_code: Optional[str]
    latitude: Optional[float]
    longitude: Optional[float]
    location_type: Optional[str]
    created_by_user_id: UUID
    created_at: datetime
    updated_at: datetime


@dataclass
class CompanyMember:
    id: UUID
    user_id: UUID
    company_id: UUID
    role: CompanyRole
    status: str
    invited_at: Optional[datetime]
    joined_at: Optional[datetime]
    invited_by_user_id: Optional[UUID]
    invitation_id: Optional[UUID]
    created_at: datetime
    updated_at: datetime


@dataclass
class CompanyInvitation:
    id: UUID
    company_id: UUID
    email: str
    role: CompanyRole
    token: str
    expires_at: datetime
    status: str
    invited_by_user_id: UUID
    created_at: datetime
    updated_at: datetime


@dataclass
class GetUserByClerkIdResult:
    id: Optional[UUID]
    clerk_id: Optional[str]
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    is_deleted: Optional[bool]


@dataclass
class GetUserByIdResult:
    id: Optional[UUID]
    clerk_id: Optional[str]
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    is_deleted: Optional[bool]


@dataclass
class UpdateUserResult:
    id: Optional[UUID]
    clerk_id: Optional[str]
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    is_deleted: Optional[bool]


@dataclass
class ListUserMembershipsResult:
    membership_id: Optional[UUID]
    company_id: Optional[UUID]
    company_name: Optional[str]
    role: Optional[str]
    status: Optional[str]
    joined_at: Optional[datetime]


@dataclass
class ListEmailInvitationsResult:
    invitation_id: Optional[UUID]
    company_id: Optional[UUID]
    company_name: Optional[str]
    role: Optional[str]
    token: Optional[str]
    expires_at: Optional[datetime]
    invited_by_user_id: Optional[UUID]
    invited_by_name: Optional[str]
    created_at: Optional[datetime]

async def create_user(conn: AsyncConnection, clerk_id: str, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None) -> Optional[UserIdentity]:
    """Function to create a new user or return existing if clerk_id matches"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_user(%s, %s, %s, %s, %s)", [clerk_id, email, email_verified, first_name, last_name])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'UserIdentity' is defined above.
        # Expecting simple tuple return for composite type UserIdentity
        try:
            instance = UserIdentity(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass UserIdentity. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_user_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> Optional[User]:
    """Function to get a user by their clerk_id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_clerk_id(%s)", [clerk_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'User' is defined above.
        # Expecting simple tuple return for composite type User
        try:
            instance = User(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass User. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_user_by_id(conn: AsyncConnection, id: UUID) -> Optional[User]:
    """Function to get a user by their internal id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_id(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'User' is defined above.
        # Expecting simple tuple return for composite type User
        try:
            instance = User(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass User. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_users(conn: AsyncConnection) -> List[User]:
    """Function to get all non-deleted users"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type User
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_user(conn: AsyncConnection, id: UUID, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, last_sign_in_at: Optional[datetime] = None) -> Optional[User]:
    """Function to update user details"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_user(%s, %s, %s, %s, %s, %s)", [id, email, email_verified, first_name, last_name, last_sign_in_at])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'User' is defined above.
        # Expecting simple tuple return for composite type User
        try:
            instance = User(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass User. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def delete_user(conn: AsyncConnection, id: UUID) -> Optional[UUID]:
    """Function to mark a user as deleted"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_user(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def create_company(conn: AsyncConnection, name: str, industry: str, size: str, primary_address: str, user_id: UUID) -> Optional[Company]:
    """Function to create a new company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_company(%s, %s, %s, %s, %s)", [name, industry, size, primary_address, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_by_id(conn: AsyncConnection, company_id: UUID) -> Optional[Company]:
    """Function to get a specific company by ID
    Note: This basic version doesn't enforce specific user access rules beyond existence.
    You might want to add checks here later (e.g., user is creator, user is part of an org associated with the company).
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_by_id(%s)", [company_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_user_companies(conn: AsyncConnection, user_id: UUID) -> List[Company]:
    """Function to list companies created by a specific user"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_user_companies(%s)", [user_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type Company
        try:
            return [Company(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Company. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_company(conn: AsyncConnection, company_id: UUID, user_id: UUID, name: Optional[str] = None, industry: Optional[str] = None, size: Optional[str] = None, primary_address: Optional[str] = None) -> Optional[Company]:
    """Function to update an existing company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_company(%s, %s, %s, %s, %s, %s)", [company_id, user_id, name, industry, size, primary_address])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def delete_company(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> None:
    """Function to delete a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_company(%s, %s)", [company_id, user_id])
        # Function returns void, no results to fetch
        return None

async def create_location(conn: AsyncConnection, company_id: UUID, name: str, user_id: UUID, address: Optional[str] = None, city: Optional[str] = None, state: Optional[str] = None, country: Optional[str] = None, zip_code: Optional[str] = None, latitude: Optional[float] = None, longitude: Optional[float] = None, location_type: Optional[str] = None) -> Optional[Location]:
    """Function to create a new location for a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_location(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)", [company_id, name, user_id, address, city, state, country, zip_code, latitude, longitude, location_type])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Location' is defined above.
        # Expecting simple tuple return for composite type Location
        try:
            instance = Location(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Location. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_location_by_id(conn: AsyncConnection, location_id: UUID) -> Optional[Location]:
    """Function to get a specific location by ID"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_location_by_id(%s)", [location_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Location' is defined above.
        # Expecting simple tuple return for composite type Location
        try:
            instance = Location(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Location. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_company_locations(conn: AsyncConnection, company_id: UUID) -> List[Location]:
    """Function to list all locations for a specific company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_company_locations(%s)", [company_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type Location
        try:
            return [Location(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Location. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_location(conn: AsyncConnection, location_id: UUID, user_id: UUID, name: Optional[str] = None, address: Optional[str] = None, city: Optional[str] = None, state: Optional[str] = None, country: Optional[str] = None, zip_code: Optional[str] = None, latitude: Optional[float] = None, longitude: Optional[float] = None, location_type: Optional[str] = None) -> Optional[Location]:
    """Function to update an existing location"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_location(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)", [location_id, user_id, name, address, city, state, country, zip_code, latitude, longitude, location_type])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Location' is defined above.
        # Expecting simple tuple return for composite type Location
        try:
            instance = Location(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Location. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def delete_location(conn: AsyncConnection, location_id: UUID, user_id: UUID) -> None:
    """Function to delete a location"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_location(%s, %s)", [location_id, user_id])
        # Function returns void, no results to fetch
        return None

async def add_company_member(conn: AsyncConnection, company_id: UUID, user_id: UUID, invited_by_user_id: UUID, role: Optional[CompanyRole] = None, status: Optional[str] = None) -> Optional[CompanyMember]:
    """Function to add a member to a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM add_company_member(%s, %s, %s, %s, %s)", [company_id, user_id, invited_by_user_id, role, status])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyMember' is defined above.
        # Expecting simple tuple return for composite type CompanyMember
        try:
            instance = CompanyMember(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_member_by_id(conn: AsyncConnection, member_id: UUID) -> Optional[CompanyMember]:
    """Function to get a specific membership by ID"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_member_by_id(%s)", [member_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyMember' is defined above.
        # Expecting simple tuple return for composite type CompanyMember
        try:
            instance = CompanyMember(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_membership(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> Optional[CompanyMember]:
    """Function to get a specific user's membership in a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_membership(%s, %s)", [company_id, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyMember' is defined above.
        # Expecting simple tuple return for composite type CompanyMember
        try:
            instance = CompanyMember(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_company_members(conn: AsyncConnection, company_id: UUID, status: Optional[str] = None) -> List[CompanyMember]:
    """Function to list all members of a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_company_members(%s, %s)", [company_id, status])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type CompanyMember
        try:
            return [CompanyMember(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def list_user_memberships(conn: AsyncConnection, user_id: UUID, status: Optional[str] = None) -> List[ListUserMembershipsResult]:
    """Function to list all companies a user is a member of"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_user_memberships(%s, %s)", [user_id, status])
        rows = await cur.fetchall()
        # Ensure dataclass 'ListUserMembershipsResult' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type ListUserMembershipsResult
        try:
            return [ListUserMembershipsResult(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for ListUserMembershipsResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_company_membership(conn: AsyncConnection, member_id: UUID, role: Optional[CompanyRole] = None, status: Optional[str] = None, joined_at: Optional[datetime] = None) -> Optional[CompanyMember]:
    """Function to update a company membership"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_company_membership(%s, %s, %s, %s)", [member_id, role, status, joined_at])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyMember' is defined above.
        # Expecting simple tuple return for composite type CompanyMember
        try:
            instance = CompanyMember(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def remove_company_member(conn: AsyncConnection, member_id: UUID) -> None:
    """Function to remove a member from a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM remove_company_member(%s)", [member_id])
        # Function returns void, no results to fetch
        return None

async def create_company_invitation(conn: AsyncConnection, company_id: UUID, email: str, invited_by_user_id: UUID, role: Optional[CompanyRole] = None, expires_in_days: Optional[int] = None) -> Optional[CompanyInvitation]:
    """Function to create a company invitation"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_company_invitation(%s, %s, %s, %s, %s)", [company_id, email, invited_by_user_id, role, expires_in_days])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_invitation_by_id(conn: AsyncConnection, invitation_id: UUID) -> Optional[CompanyInvitation]:
    """Function to get a company invitation by ID"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_invitation_by_id(%s)", [invitation_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_invitation_by_token(conn: AsyncConnection, token: str) -> Optional[CompanyInvitation]:
    """Function to get a company invitation by token"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_invitation_by_token(%s)", [token])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_company_invitations(conn: AsyncConnection, company_id: UUID, status: Optional[str] = None) -> List[CompanyInvitation]:
    """Function to list all invitations for a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_company_invitations(%s, %s)", [company_id, status])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type CompanyInvitation
        try:
            return [CompanyInvitation(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def list_email_invitations(conn: AsyncConnection, email: str, status: Optional[str] = None) -> List[ListEmailInvitationsResult]:
    """Function to list all invitations for an email address"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_email_invitations(%s, %s)", [email, status])
        rows = await cur.fetchall()
        # Ensure dataclass 'ListEmailInvitationsResult' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type ListEmailInvitationsResult
        try:
            return [ListEmailInvitationsResult(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for ListEmailInvitationsResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def accept_company_invitation(conn: AsyncConnection, token: str, user_id: UUID) -> Optional[CompanyMember]:
    """Function to accept a company invitation"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM accept_company_invitation(%s, %s)", [token, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyMember' is defined above.
        # Expecting simple tuple return for composite type CompanyMember
        try:
            instance = CompanyMember(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyMember. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def reject_company_invitation(conn: AsyncConnection, token: str) -> Optional[CompanyInvitation]:
    """Function to reject a company invitation"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM reject_company_invitation(%s)", [token])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def cancel_company_invitation(conn: AsyncConnection, invitation_id: UUID) -> Optional[CompanyInvitation]:
    """Function to cancel a company invitation"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM cancel_company_invitation(%s)", [invitation_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def resend_company_invitation(conn: AsyncConnection, invitation_id: UUID, expires_in_days: Optional[int] = None) -> Optional[CompanyInvitation]:
    """Function to resend a company invitation with a new token and expiration"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM resend_company_invitation(%s, %s)", [invitation_id, expires_in_days])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CompanyInvitation' is defined above.
        # Expecting simple tuple return for composite type CompanyInvitation
        try:
            instance = CompanyInvitation(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass CompanyInvitation. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def expire_outdated_invitations(conn: AsyncConnection) -> Optional[int]:
    """Function to expire outdated invitations"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM expire_outdated_invitations()", [])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]


# ===== SECTION: RESULT HELPERS =====
# REMOVED redundant import line

T = TypeVar('T')

def get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]:
    """\
    Safely retrieves an optional single result.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found, otherwise None.
    """
    if result is None:
        return None
    # Check if it's a list/tuple but not string/bytes
    if isinstance(result, Sequence) and not isinstance(result, (str, bytes)):
        if len(result) == 1:
            return result[0]
        else: # Empty list or list with more than one item
            return None
    else: # It's already a single item
        return result

def get_required(result: Optional[List[T]] | Optional[T]) -> T:
    """\
    Retrieves a required single result, raising an error if none or multiple are found.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found.
    Raises ValueError otherwise.
    """
    item = get_optional(result)
    if item is None:
         # Improved error message
         input_repr = repr(result)
         if len(input_repr) > 80: # Truncate long inputs
             input_repr = input_repr[:77] + '...'
         raise ValueError(f"Expected exactly one result, but got none or multiple. Input was: {input_repr}")
    return item


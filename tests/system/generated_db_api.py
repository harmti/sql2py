# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from 01_functions.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from dataclasses import dataclass
from datetime import date, datetime
from decimal import Decimal
from enum import Enum
from psycopg import AsyncConnection
from typing import List, Optional, Tuple, Dict, Any
from typing import TypeVar, Sequence

class Mood(Enum):
    SAD = 'sad'
    OK = 'ok'
    HAPPY = 'happy'


@dataclass
class ItemSummary:
    item_name: Optional[str]
    total_value: Optional[Decimal]


@dataclass
class Item:
    id: int
    name: str
    description: Optional[str]
    quantity: Optional[int]
    price: Optional[Decimal]
    is_active: Optional[bool]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    metadata: Optional[Dict[str, Any]]
    tags: Optional[List[str]]
    related_ids: Optional[List[int]]
    current_mood: Optional[Mood]


@dataclass
class SearchItemsResult:
    item_id: Optional[int]
    item_name: Optional[str]
    creation_date: Optional[date]

async def get_item_count(conn: AsyncConnection) -> Optional[int]:
    """Function returning a single scalar value"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_item_count()", [])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def get_item_by_id(conn: AsyncConnection, item_id: int) -> Optional[Item]:
    """Function returning a single row matching a table structure
    Note: The generated Python should use the 'items' table definition
    to create a Pydantic/dataclass model.
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_item_by_id(%s)", [item_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Item' is defined above.
        # Expecting simple tuple return for composite type Item
        try:
            instance = Item(
                    id=row[0],
                    name=row[1],
                    description=row[2],
                    quantity=row[3],
                    price=row[4],
                    is_active=row[5],
                    created_at=row[6],
                    updated_at=row[7],
                    metadata=row[8],
                    tags=row[9],
                    related_ids=row[10],
                    current_mood=row[11]
                )
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            if instance.current_mood is not None:
                instance.current_mood = Mood(instance.current_mood)
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Item. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_all_item_names(conn: AsyncConnection) -> List[str]:
    """Function returning SETOF scalar"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_all_item_names()", [])
        rows = await cur.fetchall()
        # Assuming SETOF returns list of single-element tuples for scalars
        return [row[0] for row in rows if row]

async def get_items_with_mood(conn: AsyncConnection, mood: Mood) -> List[Item]:
    """Function returning SETOF rows matching a table structure"""
    # Extract .value from enum parameters
    mood_value = mood.value if mood is not None else None
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_items_with_mood(%s)", [mood_value])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        # Inner helper function for efficient conversion
        def create_item(row):
            return Item(
                    id=row[0],
                    name=row[1],
                    description=row[2],
                    quantity=row[3],
                    price=row[4],
                    is_active=row[5],
                    created_at=row[6],
                    updated_at=row[7],
                    metadata=row[8],
                    tags=row[9],
                    related_ids=row[10],
                    current_mood=Mood(row[11]) if row[11] is not None else None
                )

        try:
            return [create_item(row) for row in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Item. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def search_items(conn: AsyncConnection, search_term: str) -> List[SearchItemsResult]:
    """Function returning a TABLE definition"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM search_items(%s)", [search_term])
        rows = await cur.fetchall()
        # Ensure dataclass 'SearchItemsResult' is defined above.
        if not rows:
            return []
        try:
            return [SearchItemsResult(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for SearchItemsResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_item_summaries(conn: AsyncConnection) -> List[ItemSummary]:
    """Function returning SETOF a composite type"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_item_summaries()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [ItemSummary(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for ItemSummary. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_item_timestamp(conn: AsyncConnection, item_id: int) -> None:
    """Function returning VOID (procedure-like)"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_item_timestamp(%s)", [item_id])
        # Function returns void, no results to fetch
        return None

async def get_item_description(conn: AsyncConnection, item_id: int) -> Optional[str]:
    """Function returning nullable scalar"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_item_description(%s)", [item_id])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def get_item_name_and_mood(conn: AsyncConnection, item_id: int) -> Optional[Tuple]:
    """Function returning anonymous RECORD (potentially harder to handle)
    Let's see how sql2pyapi handles this. It might require explicit type hints
    or might not be fully supported without a TABLE return.
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_item_name_and_mood(%s)", [item_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Return tuple for record type
        return row

async def get_all_names_and_moods(conn: AsyncConnection) -> List[Tuple]:
    """Function returning SETOF anonymous RECORD"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_all_names_and_moods()", [])
        rows = await cur.fetchall()
        # Return list of tuples for SETOF record
        return rows


# ===== SECTION: RESULT HELPERS =====
# REMOVED redundant import line

T = TypeVar('T')

def get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]:
    """\
    Safely retrieves an optional single result.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found, otherwise None.
    """
    if result is None:
        return None
    # Check if it's a list/tuple but not string/bytes
    if isinstance(result, Sequence) and not isinstance(result, (str, bytes)):
        if len(result) == 1:
            return result[0]
        else: # Empty list or list with more than one item
            return None
    else: # It's already a single item
        return result

def get_required(result: Optional[List[T]] | Optional[T]) -> T:
    """\
    Retrieves a required single result, raising an error if none or multiple are found.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found.
    Raises ValueError otherwise.
    """
    item = get_optional(result)
    if item is None:
         # Improved error message
         input_repr = repr(result)
         if len(input_repr) > 80: # Truncate long inputs
             input_repr = input_repr[:77] + '...'
         raise ValueError(f"Expected exactly one result, but got none or multiple. Input was: {input_repr}")
    return item


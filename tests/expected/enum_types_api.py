# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from enum_types.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from dataclasses import dataclass
from enum import Enum
from psycopg import AsyncConnection
from typing import List, Optional, Tuple, Dict, Any
from typing import TypeVar, Sequence

class StatusType(Enum):
    PENDING = 'pending'
    ACTIVE = 'active'
    INACTIVE = 'inactive'
    DELETED = 'deleted'


class UserRole(Enum):
    ADMIN = 'admin'
    MODERATOR = 'moderator'
    USER = 'user'
    GUEST = 'guest'


@dataclass
class GetUsersByStatusResult:
    user_id: Optional[int]
    username: Optional[str]
    status: Optional[StatusType]
    role: Optional[UserRole]

async def get_default_status(conn: AsyncConnection) -> StatusType:
    """Function that returns an ENUM type"""
        async with conn.cursor() as cur:
            await cur.execute("SELECT * FROM get_default_status()", [])
            row = await cur.fetchone()
            if row is None:
                return None
            return StatusType(row[0])

async def is_active_role(conn: AsyncConnection, role: UserRole) -> Optional[bool]:
    """Function that takes an ENUM parameter"""
    # Extract .value from enum parameters
        role_value = role.value if role is not None else None
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM is_active_role(%s)", [role_value])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def get_users_by_status(conn: AsyncConnection, status: StatusType) -> List[GetUsersByStatusResult]:
    """Function that returns a table with ENUM columns"""
    # Extract .value from enum parameters
        status_value = status.value if status is not None else None
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users_by_status(%s)", [status_value])
        rows = await cur.fetchall()
        # Ensure dataclass 'GetUsersByStatusResult' is defined above.
        if not rows:
            return []
        # Inner helper function for efficient conversion
        def create_getusersbystatusresult(row):
            return GetUsersByStatusResult(
                    user_id=row[0],
                    username=row[1],
                    status=StatusType(row[2]) if row[2] is not None else None,
                    role=UserRole(row[3]) if row[3] is not None else None
                )

        try:
            return [create_getusersbystatusresult(row) for row in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for GetUsersByStatusResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )


# ===== SECTION: RESULT HELPERS =====
# REMOVED redundant import line

T = TypeVar('T')

def get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]:
    """\
    Safely retrieves an optional single result.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found, otherwise None.
    """
    if result is None:
        return None
    # Check if it's a list/tuple but not string/bytes
    if isinstance(result, Sequence) and not isinstance(result, (str, bytes)):
        if len(result) == 1:
            return result[0]
        else: # Empty list or list with more than one item
            return None
    else: # It's already a single item
        return result

def get_required(result: Optional[List[T]] | Optional[T]) -> T:
    """\
    Retrieves a required single result, raising an error if none or multiple are found.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found.
    Raises ValueError otherwise.
    """
    item = get_optional(result)
    if item is None:
         # Improved error message
         input_repr = repr(result)
         if len(input_repr) > 80: # Truncate long inputs
             input_repr = input_repr[:77] + '...'
         raise ValueError(f"Expected exactly one result, but got none or multiple. Input was: {input_repr}")
    return item


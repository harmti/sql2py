# -*- coding: utf-8 -*-

# Auto-generated by sql2pyapi from func2.sql

from typing import List, Optional, Tuple, Dict, Any
from uuid import UUID
from datetime import date, datetime
from psycopg import AsyncConnection
from dataclasses import dataclass

@dataclass
class CreateUserResult:
    id: Optional[UUID]
    clerk_id: Optional[str]

@dataclass
class User:
    id: UUID
    clerk_id: str
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    is_deleted: Optional[bool]

async def create_user(conn: AsyncConnection, clerk_id: str, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None) -> Optional[CreateUserResult]:
    """Function to create a new user or return existing if clerk_id matches"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_user(%s, %s, %s, %s, %s)", [clerk_id, email, email_verified, first_name, last_name])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CreateUserResult' is defined above.
        colnames = [desc[0] for desc in cur.description]
        row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
        # Check for 'empty' composite rows (all values are None)
        if all(value is None for value in row_dict.values()):
            return None
        return CreateUserResult(**row_dict)

async def get_user_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> List[User]:
    """Function to get a user by their clerk_id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_clerk_id(%s)", [clerk_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def get_user_by_id(conn: AsyncConnection, id: UUID) -> List[User]:
    """Function to get a user by their internal id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_id(%s)", [id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def get_users(conn: AsyncConnection) -> List[User]:
    """Function to get all non-deleted users"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def update_user(conn: AsyncConnection, id: UUID, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, last_sign_in_at: Optional[datetime] = None) -> List[User]:
    """Function to update user details"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_user(%s, %s, %s, %s, %s, %s)", [id, email, email_verified, first_name, last_name, last_sign_in_at])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def delete_user(conn: AsyncConnection, id: UUID) -> Optional[UUID]:
    """Function to mark a user as deleted"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_user(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        if isinstance(row, dict):
            # Assumes the key is the function name for dict rows
            return row['delete_user']
        else:
            # Fallback for tuple-like rows (index 0)
            return row[0]

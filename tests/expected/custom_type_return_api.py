# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from custom_type_return.sql

from typing import List, Optional, Tuple, Dict, Any
from uuid import UUID
from psycopg import AsyncConnection
from dataclasses import dataclass


@dataclass
class UserIdentity:
    user_id: Optional[UUID]
    clerk_id: Optional[str]
    is_active: Optional[bool]


async def get_user_identity_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> List[UserIdentity]:
    """Function returning the custom composite type
    Assume this gets data from somewhere, exact logic doesn't matter for parsing
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_identity_by_clerk_id(%s)", [clerk_id])
        row = await cur.fetchone()
        if row is None:
            return []
        # Ensure dataclass 'UserIdentity' is defined above.
        # Assuming simple tuple return for composite type UserIdentity
        try:
            # First attempt: Direct tuple unpacking
            instance = UserIdentity(*row)
            return [instance]
        except TypeError:
            # Fallback attempt for dict-like rows (e.g., from RETURNS table_name)
            try:
                colnames = [desc[0] for desc in cur.description]
                row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
                # Check for 'empty' composite rows (all values are None)
                if all(value is None for value in row_dict.values()):
                    return []
                instance = UserIdentity(**row_dict)
                return [instance]
            except Exception as e:
                # Failed to map row to dataclass UserIdentity: {row} - Error: {e}
                return [] # Return empty list on error

async def get_all_active_identities(conn: AsyncConnection) -> List[UserIdentity]:
    """Function returning SETOF the custom composite type"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_all_active_identities()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'UserIdentity' is defined above.
        if not rows:
            return []
        # Assuming list of tuples for SETOF composite type UserIdentity
        try:
            return [UserIdentity(*r) for r in rows]
        except TypeError:
            # Fallback attempt for list of dict-like rows
            try:
                colnames = [desc[0] for desc in cur.description]
                processed_rows = [
                    dict(zip(colnames, r)) if not isinstance(r, dict) else r
                    for r in rows
                ]
                return [UserIdentity(**row_dict) for row_dict in processed_rows]
            except Exception as e:
                # Failed to map rows to dataclass list for UserIdentity - Error: {e}
                return [] # Or raise error?

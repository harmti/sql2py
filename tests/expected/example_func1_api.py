# -*- coding: utf-8 -*-

# Auto-generated by sql2pyapi from example_func1.sql

from typing import List, Optional, Tuple, Dict, Any
from uuid import UUID
from datetime import date, datetime
from psycopg import AsyncConnection
from dataclasses import dataclass

@dataclass
class Company:
    id: UUID
    name: str
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: datetime
    updated_at: datetime
    created_by_user_id: UUID

@dataclass
class CreateCompanyResult:
    id: Optional[UUID]
    name: Optional[str]
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    created_by_user_id: Optional[UUID]

@dataclass
class CreateUserResult:
    id: Optional[UUID]
    clerk_id: Optional[str]

@dataclass
class GetCompanyByIdResult:
    id: Optional[UUID]
    name: Optional[str]
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    created_by_user_id: Optional[UUID]

@dataclass
class UpdateCompanyResult:
    id: Optional[UUID]
    name: Optional[str]
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: Optional[datetime]
    updated_at: Optional[datetime]
    created_by_user_id: Optional[UUID]

@dataclass
class User:
    id: UUID
    clerk_id: str
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    is_deleted: Optional[bool]

async def create_user(conn: AsyncConnection, clerk_id: str, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None) -> Optional[CreateUserResult]:
    """Function to create a new user or return existing if clerk_id matches"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_user(%s, %s, %s, %s, %s)", [clerk_id, email, email_verified, first_name, last_name])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CreateUserResult' is defined above.
        colnames = [desc[0] for desc in cur.description]
        row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
        # Check for 'empty' composite rows (all values are None)
        if all(value is None for value in row_dict.values()):
            return None
        return CreateUserResult(**row_dict)

async def get_user_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> List[User]:
    """Function to get a user by their clerk_id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_clerk_id(%s)", [clerk_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def get_user_by_id(conn: AsyncConnection, id: UUID) -> List[User]:
    """Function to get a user by their internal id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_id(%s)", [id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def get_users(conn: AsyncConnection) -> List[User]:
    """Function to get all non-deleted users"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def update_user(conn: AsyncConnection, id: UUID, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, last_sign_in_at: Optional[datetime] = None) -> List[User]:
    """Function to update user details"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_user(%s, %s, %s, %s, %s, %s)", [id, email, email_verified, first_name, last_name, last_sign_in_at])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [User(**row_dict) for row_dict in processed_rows]

async def delete_user(conn: AsyncConnection, id: UUID) -> Optional[UUID]:
    """Function to mark a user as deleted"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_user(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        if isinstance(row, dict):
            # Assumes the key is the function name for dict rows
            return row['delete_user']
        else:
            # Fallback for tuple-like rows (index 0)
            return row[0]

async def create_company(conn: AsyncConnection, name: str, industry: str, size: str, primary_address: str, user_id: UUID) -> Optional[CreateCompanyResult]:
    """Function to create a new company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_company(%s, %s, %s, %s, %s)", [name, industry, size, primary_address, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'CreateCompanyResult' is defined above.
        colnames = [desc[0] for desc in cur.description]
        row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
        # Check for 'empty' composite rows (all values are None)
        if all(value is None for value in row_dict.values()):
            return None
        return CreateCompanyResult(**row_dict)

async def get_company_by_id(conn: AsyncConnection, company_id: UUID) -> Optional[GetCompanyByIdResult]:
    """Function to get a specific company by ID
    Note: This basic version doesn't enforce specific user access rules beyond existence.
    You might want to add checks here later (e.g., user is creator, user is part of an org associated with the company).
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_by_id(%s)", [company_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'GetCompanyByIdResult' is defined above.
        colnames = [desc[0] for desc in cur.description]
        row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
        # Check for 'empty' composite rows (all values are None)
        if all(value is None for value in row_dict.values()):
            return None
        return GetCompanyByIdResult(**row_dict)

async def list_user_companies(conn: AsyncConnection, user_id: UUID) -> List[Company]:
    """Function to list companies created by a specific user"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_user_companies(%s)", [user_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'Company' is defined above.
        if not rows:
            return []
        colnames = [desc[0] for desc in cur.description]
        processed_rows = [
            dict(zip(colnames, r)) if not isinstance(r, dict) else r
            for r in rows
        ]
        return [Company(**row_dict) for row_dict in processed_rows]

async def update_company(conn: AsyncConnection, company_id: UUID, user_id: UUID, name: Optional[str] = None, industry: Optional[str] = None, size: Optional[str] = None, primary_address: Optional[str] = None) -> Optional[UpdateCompanyResult]:
    """Function to update an existing company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_company(%s, %s, %s, %s, %s, %s)", [company_id, user_id, name, industry, size, primary_address])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'UpdateCompanyResult' is defined above.
        colnames = [desc[0] for desc in cur.description]
        row_dict = dict(zip(colnames, row)) if not isinstance(row, dict) else row
        # Check for 'empty' composite rows (all values are None)
        if all(value is None for value in row_dict.values()):
            return None
        return UpdateCompanyResult(**row_dict)

async def delete_company(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> None:
    """Function to delete a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_company(%s, %s)", [company_id, user_id])
        return None

# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from example_func1.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from typing import List, Optional, Tuple, Dict, Any
from uuid import UUID
from datetime import date, datetime
from psycopg import AsyncConnection
from dataclasses import dataclass


@dataclass
class CreateUserResult:
    id: Optional[UUID]
    clerk_id: Optional[str]


# TODO: Define dataclass for table 'users'
# @dataclass
# class User:
#     pass

# TODO: Define dataclass for table 'companies'
# @dataclass
# class Company:
#     pass


async def create_user(conn: AsyncConnection, clerk_id: str, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None) -> List[CreateUserResult]:
    """Function to create a new user or return existing if clerk_id matches"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_user(%s, %s, %s, %s, %s)", [clerk_id, email, email_verified, first_name, last_name])
        rows = await cur.fetchall()
        # Ensure dataclass 'CreateUserResult' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type CreateUserResult
        try:
            return [CreateUserResult(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for CreateUserResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_user_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> List[User]:
    """Function to get a user by their clerk_id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_clerk_id(%s)", [clerk_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type User
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_user_by_id(conn: AsyncConnection, id: UUID) -> List[User]:
    """Function to get a user by their internal id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_id(%s)", [id])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type User
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_users(conn: AsyncConnection) -> List[User]:
    """Function to get all non-deleted users"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type User
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_user(conn: AsyncConnection, id: UUID, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, last_sign_in_at: Optional[datetime] = None) -> List[User]:
    """Function to update user details"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_user(%s, %s, %s, %s, %s, %s)", [id, email, email_verified, first_name, last_name, last_sign_in_at])
        rows = await cur.fetchall()
        # Ensure dataclass 'User' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type User
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def delete_user(conn: AsyncConnection, id: UUID) -> Optional[UUID]:
    """Function to mark a user as deleted"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_user(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Expecting a tuple even for scalar returns, access first element.
        return row[0]

async def create_company(conn: AsyncConnection, name: str, industry: str, size: str, primary_address: str, user_id: UUID) -> Optional[Any]:
    """Function to create a new company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_company(%s, %s, %s, %s, %s)", [name, industry, size, primary_address, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Expecting a tuple even for scalar returns, access first element.
        return row[0]

async def get_company_by_id(conn: AsyncConnection, company_id: UUID) -> Optional[Any]:
    """Function to get a specific company by ID
    Note: This basic version doesn't enforce specific user access rules beyond existence.
    You might want to add checks here later (e.g., user is creator, user is part of an org associated with the company).
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_by_id(%s)", [company_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Expecting a tuple even for scalar returns, access first element.
        return row[0]

async def list_user_companies(conn: AsyncConnection, user_id: UUID) -> List[Company]:
    """Function to list companies created by a specific user"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_user_companies(%s)", [user_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'Company' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type Company
        try:
            return [Company(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Company. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_company(conn: AsyncConnection, company_id: UUID, user_id: UUID, name: Optional[str] = None, industry: Optional[str] = None, size: Optional[str] = None, primary_address: Optional[str] = None) -> Optional[Any]:
    """Function to update an existing company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_company(%s, %s, %s, %s, %s, %s)", [company_id, user_id, name, industry, size, primary_address])
        row = await cur.fetchone()
        if row is None:
            return None
        # Expecting a tuple even for scalar returns, access first element.
        return row[0]

async def delete_company(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> None:
    """Function to delete a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_company(%s, %s)", [company_id, user_id])
        return None

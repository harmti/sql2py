# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from example_func1.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from dataclasses import dataclass
from datetime import date, datetime
from psycopg import AsyncConnection
from typing import List, Optional, Tuple, Dict, Any
from typing import TypeVar, Sequence
from uuid import UUID

@dataclass
class User:
    id: UUID
    clerk_id: str
    email: Optional[str]
    email_verified: Optional[bool]
    first_name: Optional[str]
    last_name: Optional[str]
    last_sign_in_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    is_deleted: Optional[bool]


@dataclass
class Company:
    id: UUID
    name: str
    industry: Optional[str]
    size: Optional[str]
    primary_address: Optional[str]
    created_at: datetime
    updated_at: datetime
    created_by_user_id: UUID


@dataclass
class CreateUserResult:
    id: Optional[UUID]
    clerk_id: Optional[str]

async def create_user(conn: AsyncConnection, clerk_id: str, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None) -> List[CreateUserResult]:
    """Function to create a new user or return existing if clerk_id matches"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_user(%s, %s, %s, %s, %s)", [clerk_id, email, email_verified, first_name, last_name])
        rows = await cur.fetchall()
        # Ensure dataclass 'CreateUserResult' is defined above.
        if not rows:
            return []
        try:
            return [CreateUserResult(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for CreateUserResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_user_by_clerk_id(conn: AsyncConnection, clerk_id: str) -> List[User]:
    """Function to get a user by their clerk_id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_clerk_id(%s)", [clerk_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_user_by_id(conn: AsyncConnection, id: UUID) -> List[User]:
    """Function to get a user by their internal id"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_user_by_id(%s)", [id])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def get_users(conn: AsyncConnection) -> List[User]:
    """Function to get all non-deleted users"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_users()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_user(conn: AsyncConnection, id: UUID, email: Optional[str] = None, email_verified: Optional[bool] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, last_sign_in_at: Optional[datetime] = None) -> List[User]:
    """Function to update user details"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_user(%s, %s, %s, %s, %s, %s)", [id, email, email_verified, first_name, last_name, last_sign_in_at])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [User(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for User. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def delete_user(conn: AsyncConnection, id: UUID) -> Optional[UUID]:
    """Function to mark a user as deleted"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_user(%s)", [id])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def create_company(conn: AsyncConnection, name: str, industry: str, size: str, primary_address: str, user_id: UUID) -> Optional[Company]:
    """Function to create a new company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM create_company(%s, %s, %s, %s, %s)", [name, industry, size, primary_address, user_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def get_company_by_id(conn: AsyncConnection, company_id: UUID) -> Optional[Company]:
    """Function to get a specific company by ID
    Note: This basic version doesn't enforce specific user access rules beyond existence.
    You might want to add checks here later (e.g., user is creator, user is part of an org associated with the company).
    """
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_by_id(%s)", [company_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_user_companies(conn: AsyncConnection, user_id: UUID) -> List[Company]:
    """Function to list companies created by a specific user"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_user_companies(%s)", [user_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'None' is defined above.
        if not rows:
            return []
        try:
            return [Company(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Company. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def update_company(conn: AsyncConnection, company_id: UUID, user_id: UUID, name: Optional[str] = None, industry: Optional[str] = None, size: Optional[str] = None, primary_address: Optional[str] = None) -> Optional[Company]:
    """Function to update an existing company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM update_company(%s, %s, %s, %s, %s, %s)", [company_id, user_id, name, industry, size, primary_address])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def delete_company(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> None:
    """Function to delete a company"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM delete_company(%s, %s)", [company_id, user_id])
        # Function returns void, no results to fetch
        return None


# ===== SECTION: RESULT HELPERS =====
# REMOVED redundant import line

T = TypeVar('T')

def get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]:
    """\
    Safely retrieves an optional single result.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found, otherwise None.
    """
    if result is None:
        return None
    # Check if it's a list/tuple but not string/bytes
    if isinstance(result, Sequence) and not isinstance(result, (str, bytes)):
        if len(result) == 1:
            return result[0]
        else: # Empty list or list with more than one item
            return None
    else: # It's already a single item
        return result

def get_required(result: Optional[List[T]] | Optional[T]) -> T:
    """\
    Retrieves a required single result, raising an error if none or multiple are found.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found.
    Raises ValueError otherwise.
    """
    item = get_optional(result)
    if item is None:
         # Improved error message
         input_repr = repr(result)
         if len(input_repr) > 80: # Truncate long inputs
             input_repr = input_repr[:77] + '...'
         raise ValueError(f"Expected exactly one result, but got none or multiple. Input was: {input_repr}")
    return item


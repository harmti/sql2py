# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from schema_qualified.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from typing import List, Optional, Tuple, Dict, Any
from uuid import UUID
from datetime import date, datetime
from psycopg import AsyncConnection
from dataclasses import dataclass


@dataclass
class Company:
    id: UUID
    name: str
    description: Optional[str]
    created_at: datetime
    updated_at: datetime


async def get_company_by_id(conn: AsyncConnection, company_id: UUID) -> Optional[Company]:
    """Function returning a schema-qualified table"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_by_id(%s)", [company_id])
        row = await cur.fetchone()
        if row is None:
            return None
        # Ensure dataclass 'Company' is defined above.
        # Expecting simple tuple return for composite type Company
        try:
            instance = Company(*row)
            # Check for 'empty' composite rows (all values are None) returned as a single tuple
            # Note: This check might be DB-driver specific for NULL composites
            if all(v is None for v in row):
                 return None
            return instance
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map single row result to dataclass Company. "
                f"Check DB connection: Default tuple row_factory expected. Row: {row!r}. Error: {e}"
            )

async def list_companies(conn: AsyncConnection) -> List[Company]:
    """Function returning a SETOF schema-qualified table"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_companies()", [])
        rows = await cur.fetchall()
        # Ensure dataclass 'Company' is defined above.
        if not rows:
            return []
        # Expecting list of tuples for SETOF composite type Company
        try:
            return [Company(*r) for r in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for Company. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

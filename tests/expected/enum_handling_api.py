# -*- coding: utf-8 -*-
# Auto-generated by sql2pyapi from enum_handling.sql
#
# IMPORTANT: This code expects the database connection to use the default
# psycopg tuple row factory. It will raise errors if used with
# dictionary-based row factories (like DictRow).

from dataclasses import dataclass
from enum import Enum
from psycopg import AsyncConnection
from typing import List, Optional, Tuple, Dict, Any
from typing import TypeVar, Sequence
from uuid import UUID

class CompanyRole(Enum):
    MEMBER = 'member'
    ADMIN = 'admin'
    OWNER = 'owner'


@dataclass
class GetCompanyMemberResult:
    id: Optional[UUID]
    user_id: Optional[UUID]
    company_id: Optional[UUID]
    role: Optional[CompanyRole]


@dataclass
class ListCompanyMembersResult:
    id: Optional[UUID]
    user_id: Optional[UUID]
    company_id: Optional[UUID]
    role: Optional[CompanyRole]

async def add_company_member(conn: AsyncConnection, company_id: UUID, user_id: UUID, role: CompanyRole) -> Optional[UUID]:
    """Function taking an enum parameter"""
    # Extract .value from enum parameters
        role_value = role.value if role is not None else None
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM add_company_member(%s, %s, %s)", [company_id, user_id, role_value])
        row = await cur.fetchone()
        if row is None:
            return None
        return row[0]

async def get_user_role(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> CompanyRole:
    """Function returning an enum"""
        async with conn.cursor() as cur:
            await cur.execute("SELECT * FROM get_user_role(%s, %s)", [company_id, user_id])
            row = await cur.fetchone()
            if row is None:
                return None
            return CompanyRole(row[0])

async def get_company_member(conn: AsyncConnection, company_id: UUID, user_id: UUID) -> List[GetCompanyMemberResult]:
    """Function with a table result containing an enum"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM get_company_member(%s, %s)", [company_id, user_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'GetCompanyMemberResult' is defined above.
        if not rows:
            return []
        # Inner helper function for efficient conversion
        def create_getcompanymemberresult(row):
            return GetCompanyMemberResult(
                    id=row[0],
                    user_id=row[1],
                    company_id=row[2],
                    role=CompanyRole(row[3]) if row[3] is not None else None
                )

        try:
            return [create_getcompanymemberresult(row) for row in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for GetCompanyMemberResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )

async def list_company_members(conn: AsyncConnection, company_id: UUID) -> List[ListCompanyMembersResult]:
    """Function returning a list of table results containing an enum"""
    async with conn.cursor() as cur:
        await cur.execute("SELECT * FROM list_company_members(%s)", [company_id])
        rows = await cur.fetchall()
        # Ensure dataclass 'ListCompanyMembersResult' is defined above.
        if not rows:
            return []
        # Inner helper function for efficient conversion
        def create_listcompanymembersresult(row):
            return ListCompanyMembersResult(
                    id=row[0],
                    user_id=row[1],
                    company_id=row[2],
                    role=CompanyRole(row[3]) if row[3] is not None else None
                )

        try:
            return [create_listcompanymembersresult(row) for row in rows]
        except TypeError as e:
            # Tuple unpacking failed. This often happens if the DB connection
            # is configured with a dict-like row factory (e.g., DictRow).
            # This generated code expects the default tuple row factory.
            raise TypeError(
                f"Failed to map SETOF results to dataclass list for ListCompanyMembersResult. "
                f"Check DB connection: Default tuple row_factory expected. Error: {e}"
            )


# ===== SECTION: RESULT HELPERS =====
# REMOVED redundant import line

T = TypeVar('T')

def get_optional(result: Optional[List[T]] | Optional[T]) -> Optional[T]:
    """\
    Safely retrieves an optional single result.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found, otherwise None.
    """
    if result is None:
        return None
    # Check if it's a list/tuple but not string/bytes
    if isinstance(result, Sequence) and not isinstance(result, (str, bytes)):
        if len(result) == 1:
            return result[0]
        else: # Empty list or list with more than one item
            return None
    else: # It's already a single item
        return result

def get_required(result: Optional[List[T]] | Optional[T]) -> T:
    """\
    Retrieves a required single result, raising an error if none or multiple are found.

    Handles cases where the input is:
    - None
    - An empty list
    - A list with one item
    - A single item (non-list, non-None)

    Returns the item if exactly one is found.
    Raises ValueError otherwise.
    """
    item = get_optional(result)
    if item is None:
         # Improved error message
         input_repr = repr(result)
         if len(input_repr) > 80: # Truncate long inputs
             input_repr = input_repr[:77] + '...'
         raise ValueError(f"Expected exactly one result, but got none or multiple. Input was: {input_repr}")
    return item

